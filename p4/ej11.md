Una empresa de comunicaciones modela su red usando un grafo $\text{G}$ donde cada arista tiene una capacidad positiva que representa su **ancho de banda**.

El ancho de banda de la red es el **máximo
$\text{k}$ tal que $G_k$ es conexo**, donde $G_k$ es el subgrafo generador de $\text{G}$ que se obtiene de eliminar las aristas de peso menor a $\text{k}$

![figura 2](/img/image%20copy%202.png)

a) Proponer un algoritmo eficiente para **determinar el ancho de banda** de una red dada.

1. **Ordenar las aristas** del grafo por peso de forma decreciente.
2. **Inicializar** una estructura de unión (Union-Find) para rastrear las componentes conectadas.
3. **Recorrer las aristas** desde las de mayor peso hasta las de menor peso:
   - Agregar aristas al AGM y chequear la conectividad.
   - Verificar el momento en que el grafo pasa a ser conexo.
4. **El ancho de banda máximo** es el peso de la última arista agregada al AGM.

```cpp
#include <bits/stdc++.h>

using namespace std;

struct Arista {
    int u, v, peso;
    bool operator<(const Arista& otra) const {
        return peso > otra.peso;
    }
};

int ancho_de_banda_maximo(vector<Arista>& aristas, int n) {
    sort(aristas.begin(), aristas.end());

    //inicializar Union-Find
    dsu(n);

    int componentes = n;

    for (const auto& arista : aristas) {
        if (find(arista.u) != find(arista.v)) {
            unir(arista.u, arista.v);
            componentes--;

            if (componentes == 1) return arista.peso;
        }
    }
    return -1;
}
```
### Complejidad:
- **Ordenar aristas**: $O(m \log m)$.
- **Union-Find**: $O(m \alpha(n))$, donde $\alpha$ es la inversa de la función de Ackermann, que es casi constante.
- **Complejidad total**: $O(m \log m)$, ya que la parte dominante es el ordenamiento de las aristas.